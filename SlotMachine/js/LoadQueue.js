1./*
2.* LoadQueue
3.* Visit http://createjs.com/ for documentation, updates and examples.
4.*
5.*
6.* Copyright (c) 2012 gskinner.com, inc.
7.*
8.* Permission is hereby granted, free of charge, to any person
9.* obtaining a copy of this software and associated documentation
10.* files (the "Software"), to deal in the Software without
11.* restriction, including without limitation the rights to use,
12.* copy, modify, merge, publish, distribute, sublicense, and/or sell
13.* copies of the Software, and to permit persons to whom the
14.* Software is furnished to do so, subject to the following
15.* conditions:
16.*
17.* The above copyright notice and this permission notice shall be
18.* included in all copies or substantial portions of the Software.
19.*
20.* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
21.* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
22.* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
23.* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
24.* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
25.* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
26.* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
27.* OTHER DEALINGS IN THE SOFTWARE.
28.*/
29./**
30. * PreloadJS provides a consistent way to preload content for use in HTML applications. Preloading can be done using
31. * HTML tags, as well as XHR.
32. *
33. * By default, PreloadJS will try and load content using XHR, since it provides better support for progress and
34. * completion events, <b>however due to cross-domain issues, it may still be preferable to use tag-based loading
35. * instead</b>. Note that some content requires XHR to work (plain text, web audio), and some requires tags (HTML audio).
36. * Note this is handled automatically where possible.
37. *
38. * PreloadJS currently supports all modern browsers, and we have done our best to include support for most older
39. * browsers. If you find an issue with any specific OS/browser combination, please visit http://community.createjs.com/
40. * and report it.
41. *
42. * <h4>Getting Started</h4>
43. * To get started, check out the {{#crossLink "LoadQueue"}}{{/crossLink}} class, which includes a quick overview of how
44. * to load files and process results.
45. *
46. * <h4>Example</h4>
47. *
48. *      var queue = new createjs.LoadQueue();
49. *      queue.installPlugin(createjs.Sound);
50. *      queue.on("complete", handleComplete, this);
51. *      queue.loadFile({id:"sound", src:"http://path/to/sound.mp3"});
52. *      queue.loadManifest([
53. *          {id: "myImage", src:"path/to/myImage.jpg"}
54. *      ]);
55. *      function handleComplete() {
56. *          createjs.Sound.play("sound");
57. *          var image = queue.getResult("myImage");
58. *          document.body.appendChild(image);
59. *      }
60. *
61. * <b>Important note on plugins:</b> Plugins must be installed <i>before</i> items are added to the queue, otherwise
62. * they will not be processed, even if the load has not actually kicked off yet. Plugin functionality is handled when
63. * the items are added to the LoadQueue.
64. *
65. * <h4>Browser Support</h4>
66. * PreloadJS is partially supported in all browsers, and fully supported in all modern browsers. Known exceptions:
67. * <ul><li>XHR loading of any content will not work in many older browsers (See a matrix here: <a href="http://caniuse.com/xhr2" target="_blank">http://caniuse.com/xhr2</a>).
68. *      In many cases, you can fall back on tag loading (images, audio, CSS, scripts, SVG, and JSONP). Text and
69. *      WebAudio will only work with XHR.</li>
70. *      <li>Some formats have poor support for complete events in IE 6, 7, and 8 (SVG, tag loading of scripts, XML/JSON)</li>
71. *      <li>Opera has poor support for SVG loading with XHR</li>
72. *      <li>CSS loading in Android and Safari will not work with tags (currently, a workaround is in progress)</li>
73. *      <li>Local loading is not permitted with XHR, which is required by some file formats. When testing local content
74. *      use either a local server, or enable tag loading, which is supported for most formats. See {{#crossLink "LoadQueue/setUseXHR"}}{{/crossLink}}
75. *      for more information.</li>
76. * </ul>
77. *
78. * <h4>Cross-domain Loading</h4>
79. * Most content types can be loaded cross-domain, as long as the server supports CORS. PreloadJS also has internal
80. * support for images served from a CORS-enabled server, via the `crossOrigin` argument on the {{#crossLink "LoadQueue"}}{{/crossLink}}
81. * constructor. If set to a string value (such as "Anonymous"), the "crossOrigin" property of images generated by
82. * PreloadJS is set to that value. Please note that setting a `crossOrigin` value on an image that is served from a
83. * server without CORS will cause other errors. For more info on CORS, visit https://en.wikipedia.org/wiki/Cross-origin_resource_sharing.
84. *
85. * @module PreloadJS
86. * @main PreloadJS
87. */
88. 
89.// namespace:
90.this.createjs = this.createjs||{};
91. 
92./*
93.TODO: WINDOWS ISSUES
94.	* No error for HTML audio in IE 678
95.	* SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
96.	* No script complete handler in IE 67 TAGS (XHR is fine)
97.	* No XML/JSON in IE6 TAGS
98.	* Need to hide loading SVG in Opera TAGS
99.	* No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
100.	* SVG no load or failure in Opera XHR
101.	* Reported issues with IE7/8
102. */
103. 
104.(function() {
105.	"use strict";
106. 
107.	/**
108.	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
109.	 * a single file, or queue of files.
110.	 *
111.	 * <b>Creating a Queue</b><br />
112.	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the useXHR
113.	 * argument to false.
114.	 *
115.	 *      var queue = new createjs.LoadQueue(true);
116.	 *
117.	 * <b>Listening for Events</b><br />
118.	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink "EventDispatcher"}}{{/crossLink}}
119.	 * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>
120.	 *     <li>{{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}: fired when a queue completes loading all
121.	 *     files</li>
122.	 *     <li>{{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}: fired when the queue encounters an error with
123.	 *     any file.</li>
124.	 *     <li>{{#crossLink "AbstractLoader/progress:event"}}{{/crossLink}}: Progress for the entire queue has
125.	 *     changed.</li>
126.	 *     <li>{{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}: A single file has completed loading.</li>
127.	 *     <li>{{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}: Progress for a single file has changes. Note
128.	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>
129.	 * </ul>
130.	 *
131.	 *      queue.on("fileload", handleFileLoad, this);
132.	 *      queue.on("complete", handleComplete, this);
133.	 *
134.	 * <b>Adding files and manifests</b><br />
135.	 * Add files you want to load using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or add multiple files at a
136.	 * time using a list or a manifest definition using {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. Files are
137.	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
138.	 * like.
139.	 *
140.	 *      queue.loadFile("filePath/file.jpg");
141.	 *      queue.loadFile({id:"image", src:"filePath/file.jpg"});
142.	 *      queue.loadManifest(["filePath/file.jpg", {id:"image", src:"filePath/file.jpg"}];
143.	 *
144.	 * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not
145.	 * stop if it has already been started. Call the {{#crossLink "AbstractLoader/load"}}{{/crossLink}} method to begin
146.	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
147.	 * `loadNow` argument of `true`.
148.	 *
149.	 *      queue.load();
150.	 *
151.	 * <b>File Types</b><br />
152.	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
153.	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
154.	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
155.	 * <code>type</code> property with any manifest item.
156.	 *
157.	 *      queue.loadFile({src:"path/to/myFile.mp3x", type:createjs.LoadQueue.SOUND});
158.	 *
159.	 *      // Note that PreloadJS will not read a file extension from the query string
160.	 *      queue.loadFile({src:"http://server.com/proxy?file=image.jpg"}, type:createjs.LoadQueue.IMAGE});
161.	 *
162.	 * Supported types are defined on the LoadQueue class, and include:
163.	 * <ul>
164.	 *     <li>{{#crossLink "LoadQueue/BINARY:property"}}{{/crossLink}}: Raw binary data via XHR</li>
165.	 *     <li>{{#crossLink "LoadQueue/CSS:property"}}{{/crossLink}}: CSS files</li>
166.	 *     <li>{{#crossLink "LoadQueue/IMAGE:property"}}{{/crossLink}}: Common image formats</li>
167.	 *     <li>{{#crossLink "LoadQueue/JAVASCRIPT:property"}}{{/crossLink}}: JavaScript files</li>
168.	 *     <li>{{#crossLink "LoadQueue/JSON:property"}}{{/crossLink}}: JSON data</li>
169.	 *     <li>{{#crossLink "LoadQueue/JSONP:property"}}{{/crossLink}}: JSON files cross-domain</li>
170.	 *     <li>{{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}}: A list of files to load in JSON format, see
171.	 *     {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}</li>
172.	 *     <li>{{#crossLink "LoadQueue/SOUND:property"}}{{/crossLink}}: Audio file formats</li>
173.	 *     <li>{{#crossLink "LoadQueue/SVG:property"}}{{/crossLink}}: SVG files</li>
174.	 *     <li>{{#crossLink "LoadQueue/TEXT:property"}}{{/crossLink}}: Text files - XHR only</li>
175.	 *     <li>{{#crossLink "LoadQueue/XML:property"}}{{/crossLink}}: XML data</li>
176.	 * </ul>
177.	 *
178.	 * <b>Handling Results</b><br />
179.	 * When a file is finished downloading, a {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event is
180.	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
181.	 * resolved object that can be used immediately, including:
182.	 * <ul>
183.	 *     <li>Image: An &lt;img /&gt; tag</li>
184.	 *     <li>Audio: An &lt;audio /&gt; tag</a>
185.	 *     <li>JavaScript: A &lt;script /&gt; tag</li>
186.	 *     <li>CSS: A &lt;link /&gt; tag</li>
187.	 *     <li>XML: An XML DOM node</li>
188.	 *     <li>SVG: An &lt;object /&gt; tag</li>
189.	 *     <li>JSON: A formatted JavaScript Object</li>
190.	 *     <li>Text: Raw text</li>
191.	 *     <li>Binary: The binary loaded result</li>
192.	 * </ul>
193.	 *
194.	 *      function handleFileLoad(event) {
195.	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
196.	 *          var type = item.type;
197.	 *
198.	 *          // Add any images to the page body.
199.	 *          if (type == createjs.LoadQueue.IMAGE) {
200.	 *              document.body.appendChild(event.result);
201.	 *          }
202.	 *      }
203.	 *
204.	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
205.	 * via its "id" using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}. If no id was provided, then the "src" or
206.	 * file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong> a
207.	 * base path defined on the LoadQueue. It is recommended to always pass an id.
208.	 *
209.	 *      var image = queue.getResult("image");
210.	 *      document.body.appendChild(image);
211.	 *
212.	 * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
213.	 * event, or can be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}, passing `true` as the 2nd
214.	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
215.	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
216.	 *
217.	 *      var image = queue.getResult("image", true); // load the binary image data loaded with XHR.
218.	 *
219.	 * <b>Plugins</b><br />
220.	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
221.	 * make sure to install the <a href="http://soundjs.com">SoundJS</a> Sound class, which will help load HTML audio,
222.	 * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.
223.	 *
224.	 *      queue.installPlugin(createjs.Sound);
225.	 *
226.	 * <h4>Known Browser Issues</h4>
227.	 * <ul>
228.	 *     <li>Browsers without audio support can not load audio files.</li>
229.	 *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>
230.	 *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other
231.	 *     than Chrome will continue to download in the background.</li>
232.	 *     <li>When loading scripts using tags, they are automatically added to the document.</li>
233.	 *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>
234.	 *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
235.	 *     XHR to work.</li>
236.	 *     <li>Content loaded via tags will not show progress, and will continue to download in the background when
237.	 *     canceled, although no events will be dispatched.</li>
238.	 * </ul>
239.	 *
240.	 * @class LoadQueue
241.	 * @param {Boolean} [useXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
242.	 * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR
243.	 * when necessary.
244.	 * @param {String} [basePath=""] A path that will be prepended on to the source parameter of all items in the queue
245.	 * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`
246.	 * will not receive a base path.
247.	 * @param {String|Boolean} [crossOrigin=""] An optional flag to support images loaded from a CORS-enabled server. To
248.	 * use it, set this value to `true`, which will default the crossOrigin property on images to "Anonymous". Any
249.	 * string value will be passed through, but only "" and "Anonymous" are recommended.
250.	 * @constructor
251.	 * @extends AbstractLoader
252.	 */
253.	var LoadQueue = function(useXHR, basePath, crossOrigin) {
254.		this.init(useXHR, basePath, crossOrigin);
255.	};
256. 
257.	var p = LoadQueue.prototype = new createjs.AbstractLoader();
258.	var s = LoadQueue;
259. 
260.	/**
261.	 * Time in milliseconds to assume a load has failed. An {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
262.	 * event is dispatched if the timeout is reached before any data is received.
263.	 * @property loadTimeout
264.	 * @type {Number}
265.	 * @default 8000
266.	 * @static
267.	 * @since 0.4.1
268.	 */
269.	s.loadTimeout = 8000;
270. 
271.	/**
272.	 * Time in milliseconds to assume a load has failed.
273.	 * @type {Number}
274.	 * @deprecated in favor of the {{#crossLink "LoadQueue/loadTimeout:property"}}{{/crossLink}} property.
275.	 */
276.	s.LOAD_TIMEOUT = 0;
277. 
278.// Preload Types
279.	/**
280.	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
281.	 * @property BINARY
282.	 * @type {String}
283.	 * @default binary
284.	 * @static
285.	 */
286.	s.BINARY = "binary";
287. 
288.	/**
289.	 * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a
290.	 * &lt;style&gt; tag when loaded with tags.
291.	 * @property CSS
292.	 * @type {String}
293.	 * @default css
294.	 * @static
295.	 */
296.	s.CSS = "css";
297. 
298.	/**
299.	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.
300.	 * @property IMAGE
301.	 * @type {String}
302.	 * @default image
303.	 * @static
304.	 */
305.	s.IMAGE = "image";
306. 
307.	/**
308.	 * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a
309.	 * &lt;script&gt; tag.
310.	 *
311.	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
312.	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
313.	 * only tag-loaded scripts are injected.
314.	 * @property JAVASCRIPT
315.	 * @type {String}
316.	 * @default javascript
317.	 * @static
318.	 */
319.	s.JAVASCRIPT = "javascript";
320. 
321.	/**
322.	 * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a
323.	 * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,
324.	 * no matter what the {{#crossLink "LoadQueue/useXHR:property"}}{{/crossLink}} property is set to, and the JSON
325.	 * must contain a matching wrapper function.
326.	 * @property JSON
327.	 * @type {String}
328.	 * @default json
329.	 * @static
330.	 */
331.	s.JSON = "json";
332. 
333.	/**
334.	 * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a
335.	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
336.	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/useXHR:property"}}{{/crossLink}}
337.	 * property is set to.
338.	 * @property JSONP
339.	 * @type {String}
340.	 * @default jsonp
341.	 * @static
342.	 */
343.	s.JSONP = "jsonp";
344. 
345.	/**
346.	 * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded
347.	 * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an
348.	 * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
349.	 * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,
350.	 * regardless of what the {{#crossLink "LoadQueue/useXHR:property"}}{{/crossLink}} property is set to.
351.	 * @property MANIFEST
352.	 * @type {String}
353.	 * @default manifest
354.	 * @static
355.	 * @since 0.4.1
356.	 */
357.	s.MANIFEST = "manifest";
358. 
359.	/**
360.	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
361.	 * &lt;audio&gt; tag.
362.	 * @property SOUND
363.	 * @type {String}
364.	 * @default sound
365.	 * @static
366.	 */
367.	s.SOUND = "sound";
368. 
369.	/**
370.     * The preload type for SVG files.
371.	 * @property SVG
372.	 * @type {String}
373.	 * @default svg
374.	 * @static
375.	 */
376.	s.SVG = "svg";
377. 
378.	/**
379.	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is
380.	 * loaded as raw text.
381.	 * @property TEXT
382.	 * @type {String}
383.	 * @default text
384.	 * @static
385.	 */
386.	s.TEXT = "text";
387. 
388.	/**
389.	 * The preload type for xml files. XML is loaded into an XML document.
390.	 * @property XML
391.	 * @type {String}
392.	 * @default xml
393.	 * @static
394.	 */
395.	s.XML = "xml";
396. 
397.	/**
398.	 * Defines a POST request, use for a method value when loading data.
399.	 *
400.	 * @type {string}
401.	 */
402.	s.POST = 'POST';
403. 
404.	/**
405.	 * Defines a GET request, use for a method value when loading data.
406.	 *
407.	 * @type {string}
408.	 */
409.	s.GET = 'GET';
410. 
411. 
412.// Prototype
413.	/**
414.	 * A path that will be prepended on to the item's `src`. The `_basePath` property will only be used if an item's
415.	 * source is relative, and does not include a protocol such as `http://`, or a relative path such as `../`.
416.	 * @property _basePath
417.	 * @type {String}
418.	 * @private
419.	 * @since 0.3.1
420.	 */
421.	p._basePath = null;
422. 
423.	/**
424.	 * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
425.	 * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
426.	 * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
427.	 * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are ""
428.	 * and "Anonymous".
429.	 * @property _crossOrigin
430.	 * @type {String}
431.	 * @defaultValue ""
432.	 * @private
433.	 * @since 0.4.1
434.	 */
435.	p._crossOrigin = "";
436. 
437.	/**
438.	 * Use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR loading depending
439.	 * on the requirements for a media type. For example, HTML audio can not be loaded with XHR, and WebAudio can not be
440.	 * loaded with tags, so it will default the the correct type instead of using the user-defined type.
441.	 *
442.	 * <b>Note: This property is read-only.</b> To change it, please use the {{#crossLink "LoadQueue/setUseXHR"}}{{/crossLink}}
443.	 * method, or specify the `useXHR` argument in the LoadQueue constructor.
444.	 *
445.	 * @property useXHR
446.	 * @type {Boolean}
447.	 * @readOnly
448.	 * @default true
449.	 */
450.	p.useXHR = true;
451. 
452.	/**
453.	 * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
454.	 * @property stopOnError
455.	 * @type {Boolean}
456.	 * @default false
457.	 */
458.	p.stopOnError = false;
459. 
460.	/**
461.	 * Ensure loaded scripts "complete" in the order they are specified. Loaded scripts are added to the document head
462.	 * once they are loaded. Note that scripts loaded via tags will load one-at-a-time when this property is `true`.
463.	 * load one at a time
464.	 * @property maintainScriptOrder
465.	 * @type {Boolean}
466.	 * @default true
467.	 */
468.	p.maintainScriptOrder = true;
469. 
470.	/**
471.	 * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
472.	 * {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}} is `true`, the next queue will not be processed.
473.	 * @property next
474.	 * @type {LoadQueue}
475.	 * @default null
476.	 */
477.	p.next = null;
478. 
479.// Events
480.	/**
481.	 * This event is fired when an individual file has loaded, and been processed.
482.	 * @event fileload
483.	 * @param {Object} target The object that dispatched the event.
484.	 * @param {String} type The event type.
485.	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
486.	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
487.	 * object will contain that value as a `src` property.
488.	 * @param {Object} result The HTML tag or parsed result of the loaded item.
489.	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
490.	 * to a usable object.
491.	 * @since 0.3.0
492.	 */
493. 
494.	/**
495.	 * This event is fired when an an individual file progress changes.
496.	 * @event fileprogress
497.	 * @param {Object} The object that dispatched the event.
498.	 * @param {String} type The event type.
499.	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
500.	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
501.	 * object will contain that value as a `src` property.
502.	 * @param {Number} loaded The number of bytes that have been loaded. Note that this may just be a percentage of 1.
503.	 * @param {Number} total The total number of bytes. If it is unknown, the value is 1.
504.	 * @param {Number} progress The amount that has been loaded between 0 and 1.
505.	 * @since 0.3.0
506.	 */
507. 
508.	/**
509.	 * This event is fired when an individual file starts to load.
510.	 * @event filestart
511.	 * @param {Object} The object that dispatched the event.
512.	 * @param {String} type The event type.
513.	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
514.	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
515.	 * object will contain that value as a property.
516.	 */
517. 
518.	//TODO: Deprecated
519.	/**
520.	 * REMOVED. Use {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}} and the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
521.	 * event.
522.	 * @property onFileLoad
523.	 * @type {Function}
524.	 * @deprecated Use addEventListener and the "fileload" event.
525.	 */
526.	/**
527.	 * REMOVED. Use {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}} and the {{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}
528.	 * event.
529.	 * @property onFileProgress
530.	 * @type {Function}
531.	 * @deprecated Use addEventListener and the "fileprogress" event.
532.	 */
533. 
534. 
535.// Protected
536.	/**
537.	 * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
538.	 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
539.	 * method for more information.
540.	 * @property _typeCallbacks
541.	 * @type {Object}
542.	 * @private
543.	 */
544.	p._typeCallbacks = null;
545. 
546.	/**
547.	 * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
548.	 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
549.	 * method for more information.
550.	 * @property _extensionCallbacks
551.	 * @type {null}
552.	 * @private
553.	 */
554.	p._extensionCallbacks = null;
555. 
556.	/**
557.	 * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
558.	 * file is requested.
559.	 * @property _loadStartWasDispatched
560.	 * @type {Boolean}
561.	 * @default false
562.	 * @private
563.	 */
564.	p._loadStartWasDispatched = false;
565. 
566.	/**
567.	 * The number of maximum open connections that a loadQueue tries to maintain. Please see
568.	 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} for more information.
569.	 * @property _maxConnections
570.	 * @type {Number}
571.	 * @default 1
572.	 * @private
573.	 */
574.	p._maxConnections = 1;
575. 
576.	/**
577.	 * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
578.	 * using a script tag to do preloading.
579.	 * @property _currentlyLoadingScript
580.	 * @type {Boolean}
581.	 * @private
582.	 */
583.	p._currentlyLoadingScript = null;
584. 
585.	/**
586.	 * An array containing the currently downloading files.
587.	 * @property _currentLoads
588.	 * @type {Array}
589.	 * @private
590.	 */
591.	p._currentLoads = null;
592. 
593.	/**
594.	 * An array containing the queued items that have not yet started downloading.
595.	 * @property _loadQueue
596.	 * @type {Array}
597.	 * @private
598.	 */
599.	p._loadQueue = null;
600. 
601.	/**
602.	 * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
603.	 * @property _loadQueueBackup
604.	 * @type {Array}
605.	 * @private
606.	 */
607.	p._loadQueueBackup = null;
608. 
609.	/**
610.	 * An object hash of items that have finished downloading, indexed by item IDs.
611.	 * @property _loadItemsById
612.	 * @type {Object}
613.	 * @private
614.	 */
615.	p._loadItemsById = null;
616. 
617.	/**
618.	 * An object hash of items that have finished downloading, indexed by item source.
619.	 * @property _loadItemsBySrc
620.	 * @type {Object}
621.	 * @private
622.	 */
623.	p._loadItemsBySrc = null;
624. 
625.	/**
626.	 * An object hash of loaded items, indexed by the ID of the load item.
627.	 * @property _loadedResults
628.	 * @type {Object}
629.	 * @private
630.	 */
631.	p._loadedResults = null;
632. 
633.	/**
634.	 * An object hash of un-parsed loaded items, indexed by the ID of the load item.
635.	 * @property _loadedRawResults
636.	 * @type {Object}
637.	 * @private
638.	 */
639.	p._loadedRawResults = null;
640. 
641.	/**
642.	 * The number of items that have been requested. This helps manage an overall progress without knowing how large
643.	 * the files are before they are downloaded.
644.	 * @property _numItems
645.	 * @type {Number}
646.	 * @default 0
647.	 * @private
648.	 */
649.	p._numItems = 0;
650. 
651.	/**
652.	 * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
653.	 * the files are before they are downloaded.
654.	 * @property _numItemsLoaded
655.	 * @type {Number}
656.	 * @default 0
657.	 * @private
658.	 */
659.	p._numItemsLoaded = 0;
660. 
661.	/**
662.	 * A list of scripts in the order they were requested. This helps ensure that scripts are "completed" in the right
663.	 * order.
664.	 * @property _scriptOrder
665.	 * @type {Array}
666.	 * @private
667.	 */
668.	p._scriptOrder = null;
669. 
670.	/**
671.	 * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are
672.	 * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>
673.	 * once they are complete and have been dispatched.
674.	 * @property _loadedScripts
675.	 * @type {Array}
676.	 * @private
677.	 */
678.	p._loadedScripts = null;
679. 
680.	// Overrides abstract method in AbstractLoader
681.	p.init = function(useXHR, basePath, crossOrigin) {
682.		this._numItems = this._numItemsLoaded = 0;
683.		this._paused = false;
684.		this._loadStartWasDispatched = false;
685. 
686.		this._currentLoads = [];
687.		this._loadQueue = [];
688.		this._loadQueueBackup = [];
689.		this._scriptOrder = [];
690.		this._loadedScripts = [];
691.		this._loadItemsById = {};
692.		this._loadItemsBySrc = {};
693.		this._loadedResults = {};
694.		this._loadedRawResults = {};
695. 
696.		// Callbacks for plugins
697.		this._typeCallbacks = {};
698.		this._extensionCallbacks = {};
699. 
700.		this._basePath = basePath;
701.		this.setUseXHR(useXHR);
702.		this._crossOrigin = (crossOrigin === true)
703.				? "Anonymous" : (crossOrigin === false || crossOrigin == null)
704.				? "" : crossOrigin;
705.	};
706. 
707.	/**
708.	 * Change the usXHR value. Note that if this is set to true, it may fail depending on the browser's capabilities.
709.	 * Additionally, some files require XHR in order to load, such as JSON (without JSONP), Text, and XML, so XHR will
710.	 * be used regardless of what is passed to this method.
711.	 * @method setUseXHR
712.	 * @param {Boolean} value The new useXHR value to set.
713.	 * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if
714.	 * the provided value argument was true.
715.	 * @since 0.3.0
716.	 */
717.	p.setUseXHR = function(value) {
718.		// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
719.		//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
720.		this.useXHR = (value != false && window.XMLHttpRequest != null);
721.		return this.useXHR;
722.	};
723. 
724.	/**
725.	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
726.	 * content, and allows the queue to be used again.
727.	 * @method removeAll
728.	 * @since 0.3.0
729.	 */
730.	p.removeAll = function() {
731.		this.remove();
732.	};
733. 
734.	/**
735.	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
736.	 * This also removes internal references to loaded item(s).
737.	 *
738.	 * <h4>Example</h4>
739.	 *
740.	 *      queue.loadManifest([
741.	 *          {src:"test.png", id:"png"},
742.	 *          {src:"test.jpg", id:"jpg"},
743.	 *          {src:"test.mp3", id:"mp3"}
744.	 *      ]);
745.	 *      queue.remove("png"); // Single item by ID
746.	 *      queue.remove("png", "test.jpg"); // Items as arguments. Mixed id and src.
747.	 *      queue.remove(["test.png", "jpg"]); // Items in an Array. Mixed id and src.
748.	 *
749.	 * @method remove
750.	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
751.	 * items, or multiple items as arguments.
752.	 * @since 0.3.0
753.	 */
754.	p.remove = function(idsOrUrls) {
755.		var args = null;
756. 
757.		if (idsOrUrls && !(idsOrUrls instanceof Array)) {
758.			args = [idsOrUrls];
759.		} else if (idsOrUrls) {
760.			args = idsOrUrls;
761.		} else if (arguments.length > 0) {
762.			return;
763.		}
764. 
765.		var itemsWereRemoved = false;
766. 
767.		// Destroy everything
768.		if (!args) {
769.			this.close();
770.			for (var n in this._loadItemsById) {
771.				this._disposeItem(this._loadItemsById[n]);
772.			}
773.			this.init(this.useXHR);
774. 
775.		// Remove specific items
776.		} else {
777.			while (args.length) {
778.				var item = args.pop();
779.				var r = this.getResult(item);
780. 
781.				//Remove from the main load Queue
782.				for (i = this._loadQueue.length-1;i>=0;i--) {
783.					loadItem = this._loadQueue[i].getItem();
784.					if (loadItem.id == item || loadItem.src == item) {
785.						this._loadQueue.splice(i,1)[0].cancel();
786.						break;
787.					}
788.				}
789. 
790.				//Remove from the backup queue
791.				for (i = this._loadQueueBackup.length-1;i>=0;i--) {
792.					loadItem = this._loadQueueBackup[i].getItem();
793.					if (loadItem.id == item || loadItem.src == item) {
794.						this._loadQueueBackup.splice(i,1)[0].cancel();
795.						break;
796.					}
797.				}
798. 
799.				if (r) {
800.					delete this._loadItemsById[r.id];
801.					delete this._loadItemsBySrc[r.src];
802.					this._disposeItem(r);
803.				} else {
804.					for (var i=this._currentLoads.length-1;i>=0;i--) {
805.						var loadItem = this._currentLoads[i].getItem();
806.						if (loadItem.id == item || loadItem.src == item) {
807.							this._currentLoads.splice(i,1)[0].cancel();
808.							itemsWereRemoved = true;
809.							break;
810.						}
811.					}
812.				}
813.			}
814. 
815.			// If this was called during a load, try to load the next item.
816.			if (itemsWereRemoved) {
817.				this._loadNext();
818.			}
819.		}
820.	};
821. 
822.	/**
823.	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
824.	 * be reloaded again by calling {{#crossLink "AbstractLoader/load"}}{{/crossLink}}. Items are not removed from the
825.	 * queue. To remove items use the {{#crossLink "LoadQueue/remove"}}{{/crossLink}} or
826.	 * {{#crossLink "LoadQueue/removeAll"}}{{/crossLink}} method.
827.	 * @method reset
828.	 * @since 0.3.0
829.	 */
830.	p.reset = function() {
831.		this.close();
832.		for (var n in this._loadItemsById) {
833.			this._disposeItem(this._loadItemsById[n]);
834.		}
835. 
836.		//Reset the queue to its start state
837.		var a = [];
838.		for (var i=0, l=this._loadQueueBackup.length; i<l; i++) {
839.			a.push(this._loadQueueBackup[i].getItem());
840.		}
841. 
842.		this.loadManifest(a, false);
843.	};
844. 
845.	/**
846.	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
847.	 * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play
848.	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
849.	 * a binary result to work with. Binary files are loaded using XHR2.
850.	 * @method isBinary
851.	 * @param {String} type The item type.
852.	 * @return {Boolean} If the specified type is binary.
853.	 * @private
854.	 */
855.	s.isBinary = function(type) {
856.		switch (type) {
857.			case createjs.LoadQueue.IMAGE:
858.			case createjs.LoadQueue.BINARY:
859.				return true;
860.			default:
861.				return false;
862.		}
863.	};
864. 
865. 
866.	/**
867.	 * Determine if a specific type is a text based asset, and should be loaded as UTF-8.
868.	 * @method isText
869.	 * @param {String} type The item type.
870.	 * @return {Boolean} If the specified type is text.
871.	 * @private
872.	 */
873.	s.isText = function(type) {
874.		switch (type) {
875.			case createjs.LoadQueue.TEXT:
876.			case createjs.LoadQueue.JSON:
877.			case createjs.LoadQueue.MANIFEST:
878.			case createjs.LoadQueue.XML:
879.			case createjs.LoadQueue.HTML:
880.			case createjs.LoadQueue.CSS:
881.			case createjs.LoadQueue.SVG:
882.			case createjs.LoadQueue.JAVASCRIPT:
883.				return true;
884.			default:
885.				return false;
886.		}
887.	};
888. 
889.	/**
890.	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
891.	 * Currently, only one plugin can exist per type/extension.
892.	 *
893.	 * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information
894.	 * on this method, check out the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method in the
895.	 * {{#crossLink "SamplePlugin"}}{{/crossLink}} class.
896.	 *
897.	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned
898.	 * from the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method, it will be invoked first, and its
899.	 * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when
900.	 * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these
901.	 * methods, check out the {{#crossLink "SamplePlugin/preloadHandler"}}{{/crossLink}} and {{#crossLink "SamplePlugin/fileLoadHandler"}}{{/crossLink}}
902.	 * methods on the {{#crossLink "SamplePlugin"}}{{/crossLink}}.
903.	 *
904.	 * @method installPlugin
905.	 * @param {Function} plugin The plugin class to install.
906.	 */
907.	p.installPlugin = function(plugin) {
908.		if (plugin == null || plugin.getPreloadHandlers == null) { return; }
909.		var map = plugin.getPreloadHandlers();
910.		map.scope = plugin;
911. 
912.		if (map.types != null) {
913.			for (var i=0, l=map.types.length; i<l; i++) {
914.				this._typeCallbacks[map.types[i]] = map;
915.			}
916.		}
917.		if (map.extensions != null) {
918.			for (i=0, l=map.extensions.length; i<l; i++) {
919.				this._extensionCallbacks[map.extensions[i]] = map;
920.			}
921.		}
922.	};
923. 
924.	/**
925.	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
926.	 * number of open connections, so any additional connections may remain in a pending state until the browser
927.	 * opens the connection. When loading scripts using tags, and when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}}
928.	 * is `true`, only one script is loaded at a time due to browser limitations.
929.	 *
930.	 * <h4>Example</h4>
931.	 *
932.	 *      var queue = new createjs.LoadQueue();
933.	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
934.	 *
935.	 * @method setMaxConnections
936.	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
937.	 * is open at any time.
938.	 */
939.	p.setMaxConnections = function (value) {
940.		this._maxConnections = value;
941.		if (!this._paused && this._loadQueue.length > 0) {
942.			this._loadNext();
943.		}
944.	};
945. 
946.	/**
947.	 * Load a single file. To add multiple files at once, use the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
948.	 * method.
949.	 *
950.	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
951.	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
952.	 * @method loadFile
953.	 * @param {Object | String} file The file object or path to load. A file can be either
954.     * <ul>
955.     *     <li>A string path to a resource. Note that this kind of load item will be converted to an object (see below)
956.	 *     in the background.</li>
957.     *     <li>OR an object that contains:<ul>
958.     *         <li>src: The source of the file that is being loaded. This property is <b>required</b>. The source can
959.	 *         either be a string (recommended), or an HTML tag.</li>
960.     *         <li>type: The type of file that will be loaded (image, sound, json, etc). PreloadJS does auto-detection
961.	 *         of types using the extension. Supported types are defined on LoadQueue, such as <code>LoadQueue.IMAGE</code>.
962.	 *         It is recommended that a type is specified when a non-standard file URI (such as a php script) us used.</li>
963.     *         <li>id: A string identifier which can be used to reference the loaded object.</li>
964.	 *         <li>callback: Optional, used for JSONP requests, to define what method to call when the JSONP is loaded.</li>
965.     *         <li>data: An arbitrary data object, which is included with the loaded object</li>
966.	 *         <li>method: used to define if this request uses GET or POST when sending data to the server. The default
967.	 *         value is "GET"</li>
968.	 *         <li>values: Optional object of name/value pairs to send to the server.</li>
969.     *     </ul>
970.     * </ul>
971.	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
972.	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}}, and the value is
973.	 * `true`, the queue will resume automatically.
974.	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
975.	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},
976.	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
977.	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
978.	 * constructor, or a `path` property in a manifest definition.
979.	 */
980.	p.loadFile = function(file, loadNow, basePath) {
981.		if (file == null) {
982.			var event = new createjs.Event("error");
983.			event.text = "PRELOAD_NO_FILE";
984.			this._sendError(event);
985.			return;
986.		}
987.		this._addItem(file, null, basePath);
988. 
989.		if (loadNow !== false) {
990.			this.setPaused(false);
991.		} else {
992.			this.setPaused(true);
993.		}
994.	};
995. 
996.	/**
997.	 * Load an array of files. To load a single file, use the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} method.
998.	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
999.	 * connections are set above 1 using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Scripts will load
1000.	 * in the right order as long as {{#crossLink "LoadQueue/maintainScriptOrder"}}{{/crossLink}} is true (which is
1001.	 * default).
1002.	 *
1003.	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
1004.	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
1005.	 * @method loadManifest
1006.	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
1007.	 * manifests:
1008.	 * <ol>
1009.	 *     <li>A string path, which points to a manifest file, which is a JSON file that contains a "manifest" property,
1010.	 *     which defines the list of files to load, and can optionally contain a "path" property, which will be
1011.	 *     prepended to each file in the list.</li>
1012.	 *     <li>An object which defines a "src", which is a JSON or JSONP file. A "callback" can be defined for JSONP
1013.	 *     file. The JSON/JSONP file should contain a "manifest" property, which defines the list of files to load,
1014.	 *     and can optionally contain a "path" property, which will be prepended to each file in the list.</li>
1015.	 *     <li>An object which contains a "manifest" property, which defines the list of files to load, and can
1016.	 *     optionally contain a "path" property, which will be prepended to each file in the list.</li>
1017.	 *     <li>An Array of files to load.</li>
1018.	 * </ol>
1019.	 *
1020.	 * Each "file" in a manifest can be either:
1021.	 * <ul>
1022.	 *     <li>A string path to a resource (string). Note that this kind of load item will be converted to an object
1023.	 *     (see below) in the background.</li>
1024.	 *      <li>OR an object that contains:<ul>
1025.	 *         <li>src: The source of the file that is being loaded. This property is <b>required</b>. The source can
1026.	 *         either be a string (recommended), or an HTML tag.</li>
1027.	 *         <li>type: The type of file that will be loaded (image, sound, json, etc). PreloadJS does auto-detection
1028.	 *         of types using the extension. Supported types are defined on LoadQueue, such as <code>LoadQueue.IMAGE</code>.
1029.	 *         It is recommended that a type is specified when a non-standard file URI (such as a php script) us used.</li>
1030.	 *         <li>id: A string identifier which can be used to reference the loaded object.</li>
1031.	 *         <li>callback: Optional, used for JSONP requests, to define what method to call when the JSONP is loaded.</li>
1032.	 *         <li>data: An arbitrary data object, which is included with the loaded object</li>
1033.	 *         <li>method: used to define if this request uses GET or POST when sending data to the server. The default
1034.	 *         value is "GET"</li>
1035.	 *         <li>values: Optional object of name/value pairs to send to the server.</li>
1036.	 *     </ul>
1037.	 * </ul>
1038.	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
1039.	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} and this value is
1040.	 * `true`, the queue will resume automatically.
1041.	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
1042.	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},
1043.	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
1044.	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
1045.	 * constructor, or a `path` property in a manifest definition.
1046.	 */
1047.	p.loadManifest = function(manifest, loadNow, basePath) {
1048.		var fileList = null;
1049.		var path = null;
1050. 
1051.		// Array-based list of items
1052.		if (manifest instanceof Array) {
1053.			if (manifest.length == 0) {
1054.				var event = new createjs.Event("error");
1055.				event.text = "PRELOAD_MANIFEST_EMPTY";
1056.				this._sendError(event);
1057.				return;
1058.			}
1059.			fileList = manifest;
1060. 
1061.		// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
1062.		} else if (typeof(manifest) === "string") {
1063.			fileList = [{
1064.				src: manifest,
1065.				type: s.MANIFEST
1066.			}];
1067. 
1068.		} else if (typeof(manifest) == "object") {
1069. 
1070.			// An object that defines a manifest path
1071.			if (manifest.src !== undefined) {
1072.				if (manifest.type == null) {
1073.					manifest.type = s.MANIFEST;
1074.				} else if (manifest.type != s.MANIFEST) {
1075.					var event = new createjs.Event("error");
1076.					event.text = "PRELOAD_MANIFEST_ERROR";
1077.					this._sendError(event);
1078.				}
1079.				fileList = [manifest];
1080. 
1081.			// An object that defines a manifest
1082.			} else if (manifest.manifest !== undefined) {
1083.				fileList = manifest.manifest;
1084.				path = manifest.path;
1085.			}
1086. 
1087.		// Unsupported. This will throw an error.
1088.		} else {
1089.			var event = new createjs.Event("error");
1090.			event.text = "PRELOAD_MANIFEST_NULL";
1091.			this._sendError(event);
1092.			return;
1093.		}
1094. 
1095.		for (var i=0, l=fileList.length; i<l; i++) {
1096.			this._addItem(fileList[i], path, basePath);
1097.		}
1098. 
1099.		if (loadNow !== false) {
1100.			this.setPaused(false);
1101.		} else {
1102.			this.setPaused(true);
1103.		}
1104. 
1105.	};
1106. 
1107.	// Overrides abstract method in AbstractLoader
1108.	p.load = function() {
1109.		this.setPaused(false);
1110.	};
1111. 
1112.	/**
1113.	 * Look up a load item using either the "id" or "src" that was specified when loading it. Note that if no "id" was
1114.	 * supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
1115.	 * `basePath` will not be part of the ID.
1116.	 * @method getItem
1117.	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
1118.	 * @return {Object} The load item that was initially requested using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
1119.	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
1120.	 * event as the `item` parameter.
1121.	 */
1122.	p.getItem = function(value) {
1123.		return this._loadItemsById[value] || this._loadItemsBySrc[value];
1124.	};
1125. 
1126.	/**
1127.	 * Look up a loaded result using either the "id" or "src" that was specified when loading it. Note that if no "id"
1128.	 * was supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
1129.	 * `basePath` will not be part of the ID.
1130.	 * @method getResult
1131.	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
1132.	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
1133.	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
1134.	 * returned instead.
1135.	 * @return {Object} A result object containing the content that was loaded, such as:
1136.     * <ul>
1137.	 *      <li>An image tag (&lt;image /&gt;) for images</li>
1138.	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML
1139.	 *      DOM.</li>
1140.	 *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>
1141.	 *      <li>Raw text for TEXT</li>
1142.	 *      <li>A formatted JavaScript object defined by JSON</li>
1143.	 *      <li>An XML document</li>
1144.	 *      <li>A binary arraybuffer loaded by XHR</li>
1145.	 *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
1146.	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
1147.	 *      which can not be used to play audio back.</li>
1148.	 * </ul>
1149.     * This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}  event as the 'item`
1150.	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
1151.	 */
1152.	p.getResult = function(value, rawResult) {
1153.		var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
1154.		if (item == null) { return null; }
1155.		var id = item.id;
1156.		if (rawResult && this._loadedRawResults[id]) {
1157.			return this._loadedRawResults[id];
1158.		}
1159.		return this._loadedResults[id];
1160.	};
1161. 
1162.	/**
1163.	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
1164.	 * be processed when active loads complete. LoadQueues are not paused by default.
1165.	 *
1166.	 * Note that if new items are added to the queue using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}},
1167.	 * a paused queue will be resumed, unless the `loadNow` argument is `false`.
1168.	 * @method setPaused
1169.	 * @param {Boolean} value Whether the queue should be paused or not.
1170.	 */
1171.	p.setPaused = function(value) {
1172.		this._paused = value;
1173.		if (!this._paused) {
1174.			this._loadNext();
1175.		}
1176.	};
1177. 
1178.	// Overrides abstract method in AbstractLoader
1179.	p.close = function() {
1180.		while (this._currentLoads.length) {
1181.			this._currentLoads.pop().cancel();
1182.		}
1183.		this._scriptOrder.length = 0;
1184.		this._loadedScripts.length = 0;
1185.		this.loadStartWasDispatched = false;
1186.	};
1187. 
1188. 
1189.//Protected Methods
1190.	/**
1191.	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
1192.	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
1193.	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink "LoadQueue.getItem"}}{{/crossLink}}
1194.	 * method.
1195.	 * @method _addItem
1196.	 * @param {String|Object} value The item to add to the queue.
1197.	 * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is
1198.	 * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was
1199.	 * provided a {{#crossLink "_basePath"}}{{/crossLink}}, then it will optionally be prepended after.
1200.	 * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
1201.	 * or {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} call. This parameter will be removed in a future tagged
1202.	 * version.
1203.	 * @private
1204.	 */
1205.	p._addItem = function(value, path, basePath) {
1206.		var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
1207.		if (item == null) { return; } // Sometimes plugins or types should be skipped.
1208.		var loader = this._createLoader(item);
1209.		if (loader != null) {
1210.			this._loadQueue.push(loader);
1211.			this._loadQueueBackup.push(loader);
1212. 
1213.			this._numItems++;
1214.			this._updateProgress();
1215. 
1216.			// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
1217.			if (this.maintainScriptOrder
1218.					&& item.type == createjs.LoadQueue.JAVASCRIPT
1219.					&& loader instanceof createjs.XHRLoader) {
1220.				this._scriptOrder.push(item);
1221.				this._loadedScripts.push(null);
1222.			}
1223.		}
1224.	};
1225. 
1226.	/**
1227.	 * Create a refined load item, which contains all the required properties (src, type, extension, tag). The type of
1228.	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
1229.	 * XHR is only used for file types that support it in new browsers.
1230.	 *
1231.	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
1232.	 * alter the load item.
1233.	 * @method _createLoadItem
1234.	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
1235. 	 * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will
1236.	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink "LoadQueue/_basePath:property"}}{{/crossLink}}
1237.	 * when it is added.
1238.	 * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to
1239.	 * the path argument.
1240.	 * @return {Object} The loader instance that will be used.
1241.	 * @private
1242.	 */
1243.	p._createLoadItem = function(value, path, basePath) {
1244.		var item = null;
1245. 
1246.		// Create/modify a load item
1247.		switch(typeof(value)) {
1248.			case "string":
1249.				item = {
1250.					src: value
1251.				}; break;
1252.			case "object":
1253.				if (window.HTMLAudioElement && value instanceof window.HTMLAudioElement) {
1254.					item = {
1255.						tag: value,
1256.						src: item.tag.src,
1257.						type: createjs.LoadQueue.SOUND
1258.					};
1259.				} else {
1260.					item = value;
1261.				}
1262.				break;
1263.			default:
1264.				return null;
1265.		}
1266. 
1267.		// Determine Extension, etc.
1268.		var match = this._parseURI(item.src);
1269.		if (match != null) { item.ext = match[6]; }
1270.		if (item.type == null) {
1271.			item.type = this._getTypeByExtension(item.ext);
1272.		}
1273. 
1274.		// Inject path & basePath
1275.		var bp = ""; // Store the generated basePath
1276.		var useBasePath = basePath || this._basePath;
1277.		var autoId = item.src;
1278.		if (match && match[1] == null && match[3] == null) {
1279.			if (path) {
1280.				bp = path;
1281.				var pathMatch = this._parsePath(path);
1282.				autoId = path + autoId;
1283.				// Also append basePath
1284.				if (useBasePath != null && pathMatch && pathMatch[1] == null && pathMatch[2] == null) {
1285.					bp = useBasePath + bp;
1286.				}
1287.			} else if (useBasePath != null) {
1288.				bp = useBasePath;
1289.			}
1290.		}
1291.		item.src = bp + item.src;
1292.		item.path = bp;
1293. 
1294.		if (item.type == createjs.LoadQueue.JSON || item.type == createjs.LoadQueue.MANIFEST) {
1295.			item._loadAsJSONP = (item.callback != null);
1296.		}
1297. 
1298.		if (item.type == createjs.LoadQueue.JSONP && item.callback == null) {
1299.			throw new Error('callback is required for loading JSONP requests.');
1300.		}
1301. 
1302.		// Create a tag for the item. This ensures there is something to either load with or populate when finished.
1303.		if (item.tag === undefined || item.tag === null) {
1304.			item.tag = this._createTag(item);
1305.		}
1306. 
1307.		// If there's no id, set one now.
1308.		if (item.id === undefined || item.id === null || item.id === "") {
1309.            item.id = autoId;
1310.		}
1311. 
1312.		// Give plugins a chance to modify the loadItem:
1313.		var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
1314.		if (customHandler) {
1315.			// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
1316.			var result = customHandler.callback.call(customHandler.scope, item.src, item.type, item.id, item.data,
1317.					bp, this);
1318.			// NOTE: BasePath argument is deprecated. We pass it to plugins.allow SoundJS to modify the file. to sanymore. The full path is sent to the plugin
1319. 
1320.			// The plugin will handle the load, or has canceled it. Ignore it.
1321.			if (result === false) {
1322.				return null;
1323. 
1324.			// Load as normal:
1325.			} else if (result === true) {
1326.				// Do Nothing
1327. 
1328.			// Result is a loader class:
1329.			} else {
1330.				if (result.src != null) { item.src = result.src; }
1331.				if (result.id != null) { item.id = result.id; } // TODO: Evaluate this. An overridden ID could be problematic
1332.				if (result.tag != null) { // Assumes that the returned tag either has a load method or a src setter.
1333.					item.tag = result.tag;
1334.				}
1335.                if (result.completeHandler != null) { item.completeHandler = result.completeHandler; }
1336. 
1337.				// Allow type overriding:
1338.				if (result.type) { item.type = result.type; }
1339. 
1340.				// Update the extension in case the type changed:
1341.				match = this._parseURI(item.src);
1342.				if (match != null && match[6] != null) {
1343.					item.ext = match[6].toLowerCase();
1344.				}
1345.			}
1346.		}
1347. 
1348.		// Store the item for lookup. This also helps clean-up later.
1349.		this._loadItemsById[item.id] = item;
1350.		this._loadItemsBySrc[item.src] = item;
1351. 
1352.		return item;
1353.	};
1354. 
1355.	/**
1356.	 * Create a loader for a load item.
1357.	 * @method _createLoader
1358.	 * @param {Object} item A formatted load item that can be used to generate a loader.
1359.	 * @return {AbstractLoader} A loader that can be used to load content.
1360.	 * @private
1361.	 */
1362.	p._createLoader = function(item) {
1363.		// Initially, try and use the provided/supported XHR mode:
1364.		var useXHR = this.useXHR;
1365. 
1366.		// Determine the XHR usage overrides:
1367.		switch (item.type) {
1368.			case createjs.LoadQueue.JSON:
1369.			case createjs.LoadQueue.MANIFEST:
1370.				useXHR = !item._loadAsJSONP;
1371.				break;
1372.			case createjs.LoadQueue.XML:
1373.			case createjs.LoadQueue.TEXT:
1374.				useXHR = true; // Always use XHR2 with text/XML
1375.				break;
1376.			case createjs.LoadQueue.SOUND:
1377.			case createjs.LoadQueue.JSONP:
1378.				useXHR = false; // Never load audio using XHR. WebAudio will provide its own loader.
1379.				break;
1380.			case null:
1381.				return null;
1382.			// Note: IMAGE, CSS, SCRIPT, SVG can all use TAGS or XHR.
1383.		}
1384. 
1385.		if (useXHR) {
1386.			return new createjs.XHRLoader(item, this._crossOrigin);
1387.		} else {
1388.			return new createjs.TagLoader(item);
1389.		}
1390.	};
1391. 
1392. 
1393.	/**
1394.	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
1395.	 * is processed. The queue will "fill up" any empty slots, up to the max connection specified using
1396.	 * {{#crossLink "LoadQueue.setMaxConnections"}}{{/crossLink}} method. The only exception is scripts that are loaded
1397.	 * using tags, which have to be loaded one at a time to maintain load order.
1398.	 * @method _loadNext
1399.	 * @private
1400.	 */
1401.	p._loadNext = function() {
1402.		if (this._paused) { return; }
1403. 
1404.		// Only dispatch loadstart event when the first file is loaded.
1405.		if (!this._loadStartWasDispatched) {
1406.			this._sendLoadStart();
1407.			this._loadStartWasDispatched = true;
1408.		}
1409. 
1410.		// The queue has completed.
1411.		if (this._numItems == this._numItemsLoaded) {
1412.			this.loaded = true;
1413.			this._sendComplete();
1414. 
1415.			// Load the next queue, if it has been defined.
1416.			if (this.next && this.next.load) {
1417.				this.next.load();
1418.			}
1419.		} else {
1420.			this.loaded = false;
1421.		}
1422. 
1423.		// Must iterate forwards to load in the right order.
1424.		for (var i=0; i<this._loadQueue.length; i++) {
1425.			if (this._currentLoads.length >= this._maxConnections) { break; }
1426.			var loader = this._loadQueue[i];
1427. 
1428.			// Determine if we should be only loading one at a time:
1429.			if (this.maintainScriptOrder
1430.					&& loader instanceof createjs.TagLoader
1431.					&& loader.getItem().type == createjs.LoadQueue.JAVASCRIPT) {
1432.				if (this._currentlyLoadingScript) { continue; } // Later items in the queue might not be scripts.
1433.				this._currentlyLoadingScript = true;
1434.			}
1435.			this._loadQueue.splice(i, 1);
1436.  			i--;
1437.            this._loadItem(loader);
1438.		}
1439.	};
1440. 
1441.	/**
1442.	 * Begin loading an item. Events are not added to the loaders until the load starts.
1443.	 * @method _loadItem
1444.	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
1445.	 * @private
1446.	 */
1447.	p._loadItem = function(loader) {
1448.		loader.on("progress", this._handleProgress, this);
1449.		loader.on("complete", this._handleFileComplete, this);
1450.		loader.on("error", this._handleFileError, this);
1451.		this._currentLoads.push(loader);
1452.		this._sendFileStart(loader.getItem());
1453.		loader.load();
1454.	};
1455. 
1456.	/**
1457.	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}}
1458.	 * is set to `true`.
1459.	 * @method _handleFileError
1460.	 * @param {Object} event The error event, containing relevant error information.
1461.	 * @private
1462.	 */
1463.	p._handleFileError = function(event) {
1464.		var loader = event.target;
1465.		this._numItemsLoaded++;
1466.		this._updateProgress();
1467. 
1468.		var newEvent = new createjs.Event("error");
1469.		newEvent.text = "FILE_LOAD_ERROR";
1470.		newEvent.item = loader.getItem();
1471.		// TODO: Propagate actual error message.
1472. 
1473.		this._sendError(newEvent);
1474. 
1475.		if (!this.stopOnError) {
1476.			this._removeLoadItem(loader);
1477.			this._loadNext();
1478.		}
1479.	};
1480. 
1481.	/**
1482.	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
1483.	 * is available as the "result" property on the load item. The raw text result for a parsed item (such as JSON, XML,
1484.	 * CSS, JavaScript, etc) is available as the "rawResult" event, and can also be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}.
1485.	 * @method _handleFileComplete
1486.	 * @param {Object} event The event object from the loader.
1487.	 * @private
1488.	 */
1489.	p._handleFileComplete = function(event) {
1490.		var loader = event.target;
1491.		var item = loader.getItem();
1492. 
1493.		this._loadedResults[item.id] = loader.getResult();
1494.		if (loader instanceof createjs.XHRLoader) {
1495.			this._loadedRawResults[item.id] = loader.getResult(true);
1496.		}
1497. 
1498.		this._removeLoadItem(loader);
1499. 
1500.		// Ensure that script loading happens in the right order.
1501.		if (this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {
1502.			if (loader instanceof createjs.TagLoader) {
1503.				this._currentlyLoadingScript = false;
1504.			} else {
1505.				this._loadedScripts[createjs.indexOf(this._scriptOrder, item)] = item;
1506.				this._checkScriptLoadOrder(loader);
1507.				return;
1508.			}
1509.		}
1510. 
1511.		// Clean up the load item
1512.		delete item._loadAsJSONP;
1513. 
1514.		// If the item was a manifest, then
1515.		if (item.type == createjs.LoadQueue.MANIFEST) {
1516.			var result = loader.getResult();
1517.			if (result != null && result.manifest !== undefined) {
1518.				this.loadManifest(result, true);
1519.			}
1520.		}
1521. 
1522.		this._processFinishedLoad(item, loader);
1523.	};
1524. 
1525.	/**
1526.	 * @method _processFinishedLoad
1527.	 * @param {Object} item
1528.	 * @param {AbstractLoader} loader
1529.	 * @protected
1530.	 */
1531.	p._processFinishedLoad = function(item, loader) {
1532.		// Old handleFileTagComplete follows here.
1533.		this._numItemsLoaded++;
1534. 
1535.		this._updateProgress();
1536.		this._sendFileComplete(item, loader);
1537. 
1538.		this._loadNext();
1539.	};
1540. 
1541.	/**
1542.	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
1543.	 * order they were added, but with a "null" value. When they are completed, the value is set to the load item,
1544.	 * and then when they are processed and dispatched, the value is set to <code>true</code>. This method simply
1545.	 * iterates the array, and ensures that any loaded items that are not preceded by a <code>null</code> value are
1546.	 * dispatched.
1547.	 * @method _checkScriptLoadOrder
1548.	 * @private
1549.	 */
1550.	p._checkScriptLoadOrder = function () {
1551.		var l = this._loadedScripts.length;
1552. 
1553.		for (var i=0;i<l;i++) {
1554.			var item = this._loadedScripts[i];
1555.			if (item === null) { break; } // This is still loading. Do not process further.
1556.			if (item === true) { continue; } // This has completed, and been processed. Move on.
1557. 
1558.			// Append script tags to the head automatically. Tags do this in the loader, but XHR scripts have to maintain order.
1559.			var loadItem = this._loadedResults[item.id];
1560.			(document.body || document.getElementsByTagName("body")[0]).appendChild(loadItem);
1561. 
1562.			this._processFinishedLoad(item);
1563.			this._loadedScripts[i] = true;
1564.		}
1565.	};
1566. 
1567.	/**
1568.	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
1569.	 * @method _removeLoadItem
1570.	 * @param {AbstractLoader} loader A loader instance to remove.
1571.	 * @private
1572.	 */
1573.	p._removeLoadItem = function(loader) {
1574.		var l = this._currentLoads.length;
1575.		for (var i=0;i<l;i++) {
1576.			if (this._currentLoads[i] == loader) {
1577.				this._currentLoads.splice(i,1); break;
1578.			}
1579.		}
1580.	};
1581. 
1582.	/**
1583.	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue overall progress.
1584.	 * @method _handleProgress
1585.	 * @param {Object} event The progress event from the item.
1586.	 * @private
1587.	 */
1588.	p._handleProgress = function(event) {
1589.		var loader = event.target;
1590.		this._sendFileProgress(loader.getItem(), loader.progress);
1591.		this._updateProgress();
1592.	};
1593. 
1594.	/**
1595.	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
1596.	 * item dispatches progress or completes. Note that since we don't know the actual filesize of items before they are
1597.	 * loaded, and even then we can only get the size of items loaded with XHR. In this case, we define a "slot" for
1598.	 * each item (1 item in 10 would get 10%), and then append loaded progress on top of the already-loaded items.
1599.	 *
1600.	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:<ul>
1601.	 *      <li>5/10 of the items in the queue (50%)</li>
1602.	 *      <li>plus 20% of item 6's slot (2%)</li>
1603.	 *      <li>equals 52%</li></ul>
1604.	 * @method _updateProgress
1605.	 * @private
1606.	 */
1607.	p._updateProgress = function () {
1608.		var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
1609.		var remaining = this._numItems-this._numItemsLoaded;
1610.		if (remaining > 0) {
1611.			var chunk = 0;
1612.			for (var i=0, l=this._currentLoads.length; i<l; i++) {
1613.				chunk += this._currentLoads[i].progress;
1614.			}
1615.			loaded += (chunk / remaining) * (remaining/this._numItems);
1616.		}
1617.		this._sendProgress(loaded);
1618.	};
1619. 
1620.	/**
1621.	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
1622.	 * hashes.
1623.	 * @method _disposeItem
1624.	 * @param {Object} item The item that was passed in for preloading.
1625.	 * @private
1626.	 */
1627.	p._disposeItem = function(item) {
1628.		delete this._loadedResults[item.id];
1629.		delete this._loadedRawResults[item.id];
1630.		delete this._loadItemsById[item.id];
1631.		delete this._loadItemsBySrc[item.src];
1632.	};
1633. 
1634. 
1635.	/**
1636.	 * Create an HTML tag. This is in LoadQueue instead of {{#crossLink "TagLoader"}}{{/crossLink}} because no matter
1637.	 * how we load the data, we may need to return it in a tag.
1638.	 * @method _createTag
1639.	 * @param {String} type The item type. Items are passed in by the developer, or deteremined by the extension.
1640.	 * @return {HTMLImageElement|HTMLAudioElement|HTMLScriptElement|HTMLLinkElement|Object} The tag that is created.
1641.	 * Note that tags are not appended to the HTML body.
1642.	 * @private
1643.	 */
1644.	p._createTag = function(item) {
1645.		var tag = null;
1646.		switch (item.type) {
1647.			case createjs.LoadQueue.IMAGE:
1648.				tag = document.createElement("img");
1649.				if (this._crossOrigin != "" && !this._isLocal(item)) { tag.crossOrigin = this._crossOrigin; }
1650.				return tag;
1651.			case createjs.LoadQueue.SOUND:
1652.				tag = document.createElement("audio");
1653.				tag.autoplay = false;
1654.				// Note: The type property doesn't seem necessary.
1655.				return tag;
1656.			case createjs.LoadQueue.JSON:
1657.			case createjs.LoadQueue.JSONP:
1658.			case createjs.LoadQueue.JAVASCRIPT:
1659.			case createjs.LoadQueue.MANIFEST:
1660.				tag = document.createElement("script");
1661.				tag.type = "text/javascript";
1662.				return tag;
1663.			case createjs.LoadQueue.CSS:
1664.				if (this.useXHR) {
1665.					tag = document.createElement("style");
1666.				} else {
1667.					tag = document.createElement("link");
1668.				}
1669.				tag.rel  = "stylesheet";
1670.				tag.type = "text/css";
1671.				return tag;
1672.			case createjs.LoadQueue.SVG:
1673.				if (this.useXHR) {
1674.					tag = document.createElement("svg");
1675.				} else {
1676.					tag = document.createElement("object");
1677.					tag.type = "image/svg+xml";
1678.				}
1679.				return tag;
1680.		}
1681.		return null;
1682.	};
1683. 
1684.	/**
1685.	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
1686.	 * if it is an unusual extension.
1687.	 * @param {String} extension The file extension to use to determine the load type.
1688.	 * @return {String} The determined load type (for example, <code>LoadQueue.IMAGE</code> or null if it can not be
1689.	 * determined by the extension.
1690.	 * @private
1691.	 */
1692.	p._getTypeByExtension = function(extension) {
1693.		if (extension == null) {
1694.			return createjs.LoadQueue.TEXT;
1695.		}
1696.		switch (extension.toLowerCase()) {
1697.			case "jpeg":
1698.			case "jpg":
1699.			case "gif":
1700.			case "png":
1701.			case "webp":
1702.			case "bmp":
1703.				return createjs.LoadQueue.IMAGE;
1704.			case "ogg":
1705.			case "mp3":
1706.			case "wav":
1707.				return createjs.LoadQueue.SOUND;
1708.			case "json":
1709.				return createjs.LoadQueue.JSON;
1710.			case "xml":
1711.				return createjs.LoadQueue.XML;
1712.			case "css":
1713.				return createjs.LoadQueue.CSS;
1714.			case "js":
1715.				return createjs.LoadQueue.JAVASCRIPT;
1716.			case 'svg':
1717.				return createjs.LoadQueue.SVG;
1718.			default:
1719.				return createjs.LoadQueue.TEXT;
1720.		}
1721.	};
1722. 
1723.	/**
1724.	 * Dispatch a fileprogress event (and onFileProgress callback). Please see the <code>LoadQueue.fileprogress</code>
1725.	 * event for details on the event payload.
1726.	 * @method _sendFileProgress
1727.	 * @param {Object} item The item that is being loaded.
1728.	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
1729.	 * @protected
1730.	 */
1731.	p._sendFileProgress = function(item, progress) {
1732.		if (this._isCanceled()) {
1733.			this._cleanUp();
1734.			return;
1735.		}
1736.		if (!this.hasEventListener("fileprogress")) { return; }
1737. 
1738.		var event = new createjs.Event("fileprogress");
1739.		event.progress = progress;
1740.		event.loaded = progress;
1741.		event.total = 1;
1742.		event.item = item;
1743. 
1744.		this.dispatchEvent(event);
1745.	};
1746. 
1747.	/**
1748.	 * Dispatch a fileload event. Please see the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event for
1749.	 * details on the event payload.
1750.	 * @method _sendFileComplete
1751.	 * @param {Object} item The item that is being loaded.
1752.	 * @param {TagLoader | XHRLoader} loader
1753.	 * @protected
1754.	 */
1755.	p._sendFileComplete = function(item, loader) {
1756.		if (this._isCanceled()) { return; }
1757. 
1758.		var event = new createjs.Event("fileload");
1759.		event.loader = loader;
1760.		event.item = item;
1761.		event.result = this._loadedResults[item.id];
1762.		event.rawResult = this._loadedRawResults[item.id];
1763. 
1764.        // This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
1765.        if (item.completeHandler) {
1766.            item.completeHandler(event);
1767.        }
1768. 
1769.		this.hasEventListener("fileload") && this.dispatchEvent(event)
1770.	};
1771. 
1772.	/**
1773.	 * Dispatch a filestart event immediately before a file starts to load. Please see the {{#crossLink "LoadQueue/filestart:event"}}{{/crossLink}}
1774.	 * event for details on the event payload.
1775.	 * @method _sendFileStart
1776.	 * @param {Object} item The item that is being loaded.
1777.	 * @protected
1778.	 */
1779.	p._sendFileStart = function(item) {
1780.		var event = new createjs.Event("filestart");
1781.		event.item = item;
1782.		this.hasEventListener("filestart") && this.dispatchEvent(event);
1783.	};
1784. 
1785.	/**
1786.	 * REMOVED.  Use createjs.proxy instead
1787.	 * @method proxy
1788.	 * @param {Function} method The function to call
1789.	 * @param {Object} scope The scope to call the method name on
1790.	 * @static
1791.	 * @private
1792.	 * @deprecated In favour of the createjs.proxy method (see LoadQueue source).
1793.	 */
1794. 
1795.	p.toString = function() {
1796.		return "[PreloadJS LoadQueue]";
1797.	};
1798. 
1799.	createjs.LoadQueue = LoadQueue;
1800. 
1801. 
1802.// Helper methods
1803. 
1804.	// An additional module to determine the current browser, version, operating system, and other environmental variables.
1805.	var BrowserDetect = function() {}
1806. 
1807.	BrowserDetect.init = function() {
1808.		var agent = navigator.userAgent;
1809.		BrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);
1810.		BrowserDetect.isOpera = (window.opera != null);
1811.		BrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);
1812.		BrowserDetect.isIOS = agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1;
1813.	};
1814. 
1815.	BrowserDetect.init();
1816. 
1817.	createjs.LoadQueue.BrowserDetect = BrowserDetect;
1818. 
1819.}());

